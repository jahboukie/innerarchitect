#!/usr/bin/env python3
"""
HIPAA Security Penetration Testing Script for The Inner Architect

This script performs automated security testing to verify the effectiveness
of security controls implemented in The Inner Architect application. It tests
encryption, access controls, audit logging, and other security features.

Usage:
    python security/pentest.py --all              # Run all tests
    python security/pentest.py --encryption       # Test encryption only
    python security/pentest.py --access-control   # Test access controls only
    python security/pentest.py --audit            # Test audit logging only
    python security/pentest.py --report           # Generate detailed report
"""

import os
import sys
import time
import json
import uuid
import hashlib
import requests
import argparse
import logging
import datetime
import unittest
import binascii
from typing import Dict, List, Any, Optional, Tuple
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from flask import Flask, current_app
from flask_testing import TestCase

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.FileHandler("security_pentest.log"),
        logging.StreamHandler(sys.stdout)
    ]
)

logger = logging.getLogger("security_pentest")

# Create test application
def create_test_app():
    """Create a test application for testing security components"""
    from app import app as flask_app
    flask_app.config['TESTING'] = True
    flask_app.config['WTF_CSRF_ENABLED'] = False
    flask_app.config['ENCRYPTION_TEST_KEY'] = 'VGhpc0lzQVRlc3RLZXlPbmx5Rm9yVGVzdGluZ1B1cnBvc2Vz'
    return flask_app

class SecurityPenetrationTest:
    """Main penetration testing framework"""
    
    def __init__(self, app=None):
        self.app = app or create_test_app()
        self.reports = []
        self.vulnerabilities = []
        self.test_users = {}
        self.results = {
            'passed': 0,
            'failed': 0,
            'warnings': 0,
            'vulnerabilities': []
        }
        
    def run_all_tests(self):
        """Run all security tests"""
        logger.info("Starting comprehensive security penetration test")
        
        # Test encryption
        self.test_encryption()
        
        # Test access controls
        self.test_access_controls()
        
        # Test audit logging
        self.test_audit_logging()
        
        # Test authentication
        self.test_authentication()
        
        # Test session security
        self.test_session_security()
        
        # Test API security
        self.test_api_security()
        
        # Generate report
        self.generate_report()
        
    def test_encryption(self):
        """Test encryption implementation"""
        logger.info("Testing encryption system")
        
        with self.app.app_context():
            try:
                # Get encryption manager
                encryption = self.app.extensions.get('encryption')
                if not encryption:
                    self._log_vulnerability(
                        'critical', 
                        'Encryption system not initialized',
                        'The encryption manager was not found in app extensions',
                        'Initialize encryption system properly'
                    )
                    return
                
                # Test basic encryption and decryption
                test_data = f"Test data with timestamp {time.time()}"
                encrypted = encryption.encrypt(test_data, purpose='test')
                decrypted = encryption.decrypt(encrypted)
                
                if decrypted.decode('utf-8') != test_data:
                    self._log_vulnerability(
                        'critical',
                        'Encryption/decryption failure',
                        'Data was not correctly decrypted after encryption',
                        'Verify encryption implementation and key management'
                    )
                else:
                    logger.info("✓ Basic encryption/decryption test passed")
                    self.results['passed'] += 1
                
                # Test different purposes isolation
                encrypted_1 = encryption.encrypt("Same data", purpose='purpose1')
                encrypted_2 = encryption.encrypt("Same data", purpose='purpose2')
                
                if encrypted_1 == encrypted_2:
                    self._log_vulnerability(
                        'high',
                        'Purpose-specific encryption not working',
                        'Different purposes produced the same ciphertext',
                        'Verify purpose-specific key derivation'
                    )
                else:
                    logger.info("✓ Purpose isolation test passed")
                    self.results['passed'] += 1
                
                # Test encryption field type decorator
                from security.encryption import EncryptedField
                field = EncryptedField(purpose='db-field')
                
                test_value = f"Sensitive value {uuid.uuid4()}"
                encrypted_value = field.process_bind_param(test_value, None)
                decrypted_value = field.process_result_value(encrypted_value, None)
                
                if decrypted_value != test_value:
                    self._log_vulnerability(
                        'high',
                        'EncryptedField not working correctly',
                        'Field encryption/decryption failed',
                        'Verify EncryptedField implementation'
                    )
                else:
                    logger.info("✓ EncryptedField test passed")
                    self.results['passed'] += 1
                
                # Test payload encryption
                from security.encryption import encrypt_payload, decrypt_payload
                
                test_payload = {'sensitive': 'data', 'timestamp': time.time()}
                encrypted_payload = encrypt_payload(test_payload, purpose='api')
                
                # Verify encrypted payload has expected format
                if not encrypted_payload.get('encrypted') or not encrypted_payload.get('data'):
                    self._log_vulnerability(
                        'medium',
                        'API payload encryption format invalid',
                        'Encrypted payload missing required fields',
                        'Verify encrypt_payload implementation'
                    )
                else:
                    # Test decryption
                    decrypted_payload = decrypt_payload(encrypted_payload)
                    if decrypted_payload != test_payload:
                        self._log_vulnerability(
                            'high',
                            'API payload encryption/decryption failure',
                            'Payload was not correctly decrypted',
                            'Verify payload encryption implementation'
                        )
                    else:
                        logger.info("✓ API payload encryption test passed")
                        self.results['passed'] += 1
                
                # Test tampering resistance
                # Tamper with the encrypted data
                try:
                    import base64
                    import json
                    tampered = base64.b64decode(encrypted.encode('utf-8')).decode('utf-8')
                    tampered_data = json.loads(tampered)
                    # Modify the data
                    tampered_data['d'] = tampered_data['d'][:-5] + 'AAAAA'
                    # Re-encode
                    tampered = base64.b64encode(json.dumps(tampered_data).encode('utf-8')).decode('utf-8')
                    
                    # Try to decrypt
                    try:
                        encryption.decrypt(tampered)
                        self._log_vulnerability(
                            'critical',
                            'Encryption lacks tamper protection',
                            'Tampered data was decrypted without error',
                            'Verify authentication tag verification in decryption'
                        )
                    except ValueError:
                        # This is expected - tampered data should fail
                        logger.info("✓ Tamper protection test passed")
                        self.results['passed'] += 1
                except Exception as e:
                    logger.error(f"Error in tamper test: {e}")
                
            except Exception as e:
                self._log_vulnerability(
                    'critical',
                    'Encryption system exception',
                    f'Exception during encryption testing: {str(e)}',
                    'Review encryption implementation for errors'
                )
                logger.error(f"Error testing encryption: {e}")
    
    def test_access_controls(self):
        """Test access control implementation"""
        logger.info("Testing access control system")
        
        with self.app.app_context():
            try:
                # Get security manager
                security = self.app.extensions.get('security')
                if not security:
                    self._log_vulnerability(
                        'critical', 
                        'Security manager not initialized',
                        'The security manager was not found in app extensions',
                        'Initialize security system properly'
                    )
                    return
                
                # Test RBAC role checks
                class MockUser:
                    def __init__(self, roles):
                        self.roles = roles
                        self.id = 'test_user'
                
                # Admin user should have all permissions
                admin_user = MockUser(['admin'])
                for permission in ['read:phi', 'write:phi', 'admin:system']:
                    if not security.has_permission(admin_user, permission):
                        self._log_vulnerability(
                            'high',
                            'RBAC admin permissions not working',
                            f'Admin user denied {permission} permission',
                            'Verify RBAC role configuration'
                        )
                        break
                else:
                    logger.info("✓ Admin role permissions test passed")
                    self.results['passed'] += 1
                
                # Regular user should have limited permissions
                regular_user = MockUser(['user'])
                if security.has_permission(regular_user, 'read:phi'):
                    self._log_vulnerability(
                        'critical',
                        'RBAC permission leakage',
                        'Regular user granted PHI access permission',
                        'Verify RBAC permission restrictions'
                    )
                else:
                    logger.info("✓ Regular user permission restriction test passed")
                    self.results['passed'] += 1
                
                # Test permission pattern matching
                practitioner = MockUser(['practitioner'])
                if not security.has_permission(practitioner, 'read:phi'):
                    self._log_vulnerability(
                        'medium',
                        'RBAC permission pattern matching issue',
                        'Practitioner denied expected PHI read permission',
                        'Verify permission pattern matching'
                    )
                else:
                    logger.info("✓ Permission pattern matching test passed")
                    self.results['passed'] += 1
                
                # Test MFA components
                try:
                    # Generate and verify TOTP code
                    secret = security.generate_mfa_secret()
                    
                    # Test recovery codes
                    recovery_codes = security.get_recovery_codes(5)
                    if len(recovery_codes) != 5:
                        self._log_vulnerability(
                            'low',
                            'MFA recovery code generation issue',
                            f'Expected 5 recovery codes, got {len(recovery_codes)}',
                            'Verify recovery code generation'
                        )
                    
                    # Test recovery code hashing
                    hashed_codes = security.hash_recovery_codes(recovery_codes)
                    
                    # Try to verify a recovery code
                    is_valid, updated_codes = security.verify_recovery_code(
                        recovery_codes[0], hashed_codes
                    )
                    
                    if not is_valid:
                        self._log_vulnerability(
                            'high',
                            'MFA recovery code verification failure',
                            'Recovery code verification failed for valid code',
                            'Verify recovery code hashing and verification'
                        )
                    elif len(updated_codes) != len(hashed_codes) - 1:
                        self._log_vulnerability(
                            'medium',
                            'MFA recovery code usage issue',
                            'Used recovery code was not removed from the list',
                            'Verify recovery code usage logic'
                        )
                    else:
                        logger.info("✓ MFA recovery code test passed")
                        self.results['passed'] += 1
                    
                except Exception as e:
                    self._log_vulnerability(
                        'high',
                        'MFA implementation error',
                        f'Exception in MFA testing: {str(e)}',
                        'Review MFA implementation'
                    )
                    logger.error(f"Error testing MFA: {e}")
            
            except Exception as e:
                self._log_vulnerability(
                    'critical',
                    'Access control system exception',
                    f'Exception during access control testing: {str(e)}',
                    'Review access control implementation for errors'
                )
                logger.error(f"Error testing access controls: {e}")
    
    def test_audit_logging(self):
        """Test audit logging implementation"""
        logger.info("Testing audit logging system")
        
        with self.app.app_context():
            try:
                # Get audit manager
                audit = self.app.extensions.get('audit')
                if not audit:
                    self._log_vulnerability(
                        'critical', 
                        'Audit manager not initialized',
                        'The audit manager was not found in app extensions',
                        'Initialize audit system properly'
                    )
                    return
                
                # Test basic audit logging
                try:
                    # Create a test log entry
                    log_entry = audit.log_event(
                        event_type='test',
                        action='pentest',
                        resource_type='security',
                        resource_id='test_resource',
                        details={'test': True, 'timestamp': time.time()},
                        success=True
                    )
                    
                    # Verify log entry was created
                    if not log_entry or not log_entry.id:
                        self._log_vulnerability(
                            'high',
                            'Audit logging failure',
                            'Failed to create audit log entry',
                            'Verify audit logging implementation'
                        )
                    else:
                        logger.info(f"✓ Audit log creation test passed: {log_entry.id}")
                        self.results['passed'] += 1
                    
                    # Verify log entry hash
                    if not log_entry.entry_hash or len(log_entry.entry_hash) != 64:
                        self._log_vulnerability(
                            'high',
                            'Audit log integrity issue',
                            'Audit log entry hash missing or invalid',
                            'Verify log entry hashing'
                        )
                    else:
                        logger.info("✓ Audit log hash test passed")
                        self.results['passed'] += 1
                
                except Exception as e:
                    self._log_vulnerability(
                        'high',
                        'Audit logging implementation error',
                        f'Exception in audit logging: {str(e)}',
                        'Review audit logging implementation'
                    )
                    logger.error(f"Error in audit logging: {e}")
                
                # Test log verification
                try:
                    # Verify log chain integrity
                    integrity_check = audit.verify_log_integrity(
                        start_date=datetime.datetime.utcnow() - datetime.timedelta(hours=1)
                    )
                    
                    if not integrity_check:
                        self._log_vulnerability(
                            'critical',
                            'Audit log integrity failure',
                            'Log chain verification failed',
                            'Verify log chaining implementation'
                        )
                    else:
                        logger.info("✓ Audit log integrity verification test passed")
                        self.results['passed'] += 1
                    
                    # Test log export
                    export_data = audit.export_audit_trail(
                        start_date=datetime.datetime.utcnow() - datetime.timedelta(hours=1),
                        end_date=datetime.datetime.utcnow(),
                        format='json'
                    )
                    
                    if not export_data or 'entries' not in export_data:
                        self._log_vulnerability(
                            'medium',
                            'Audit log export issue',
                            'Failed to export audit trail or invalid format',
                            'Verify audit trail export functionality'
                        )
                    else:
                        logger.info("✓ Audit log export test passed")
                        self.results['passed'] += 1
                    
                except Exception as e:
                    self._log_vulnerability(
                        'high',
                        'Audit log verification error',
                        f'Exception in log verification: {str(e)}',
                        'Review audit log verification implementation'
                    )
                    logger.error(f"Error in audit log verification: {e}")
            
            except Exception as e:
                self._log_vulnerability(
                    'critical',
                    'Audit system exception',
                    f'Exception during audit testing: {str(e)}',
                    'Review audit implementation for errors'
                )
                logger.error(f"Error testing audit system: {e}")
    
    def test_authentication(self):
        """Test authentication implementation"""
        logger.info("Testing authentication system")
        
        # Test MFA bypass attempts
        with self.app.test_client() as client:
            # Try accessing MFA-protected route without authentication
            response = client.get('/security/mfa/setup', follow_redirects=False)
            if response.status_code != 302:  # Should redirect to login
                self._log_vulnerability(
                    'high',
                    'MFA setup authentication bypass',
                    'MFA setup accessible without authentication',
                    'Verify login_required decorator on MFA routes'
                )
            else:
                logger.info("✓ MFA unauthenticated access prevention test passed")
                self.results['passed'] += 1
            
            # Try direct access to recovery codes page
            response = client.get('/security/mfa/recovery_codes', follow_redirects=False)
            if response.status_code < 400:  # Should be 404 or redirect
                self._log_vulnerability(
                    'critical',
                    'MFA recovery codes authentication bypass',
                    'Recovery codes accessible without authentication',
                    'Verify authentication for recovery codes access'
                )
        
        # Test password policy
        with self.app.app_context():
            from werkzeug.security import generate_password_hash
            
            # Test if weak passwords are rejected (would require route testing in real app)
            weak_passwords = [
                'password',
                '123456',
                'qwerty',
                'abc123',
                'letmein'
            ]
            
            # In a real test, would check if application rejects these passwords
            logger.info("Weak password testing requires manual verification")
            self.results['warnings'] += 1
    
    def test_session_security(self):
        """Test session security implementation"""
        logger.info("Testing session security")
        
        # Test session timeout
        with self.app.test_client() as client:
            # Set up a test session
            with client.session_transaction() as session:
                session['last_active'] = int(time.time()) - 3600  # 1 hour ago
                session['user_id'] = 'test_user'
            
            # Make a request with the expired session
            # In a real test, this would check if the application redirects to login
            logger.info("Session timeout testing requires manual verification")
            self.results['warnings'] += 1
            
            # Test session fixation protection
            # In a real test, would check if session ID changes after login
            logger.info("Session fixation testing requires manual verification")
            self.results['warnings'] += 1
    
    def test_api_security(self):
        """Test API security implementation"""
        logger.info("Testing API security")
        
        # Test CSRF protection
        with self.app.test_client() as client:
            # Try making a POST request without CSRF token
            response = client.post('/api/example', data={'test': 'data'})
            
            # In a real app, this should fail with CSRF error
            # Here we just note it requires manual verification
            logger.info("CSRF protection testing requires manual verification")
            self.results['warnings'] += 1
        
        # Test API rate limiting
        # Would test if application limits requests appropriately
        logger.info("API rate limiting requires manual verification")
        self.results['warnings'] += 1
    
    def _log_vulnerability(self, severity, title, description, recommendation):
        """Log a discovered vulnerability"""
        vulnerability = {
            'severity': severity,
            'title': title,
            'description': description,
            'recommendation': recommendation,
            'timestamp': datetime.datetime.utcnow().isoformat()
        }
        
        logger.warning(f"VULNERABILITY FOUND: {severity} - {title}")
        self.vulnerabilities.append(vulnerability)
        self.results['vulnerabilities'].append(vulnerability)
        self.results['failed'] += 1
    
    def generate_report(self):
        """Generate a comprehensive security test report"""
        logger.info("Generating security test report")
        
        report = {
            'timestamp': datetime.datetime.utcnow().isoformat(),
            'summary': {
                'passed': self.results['passed'],
                'failed': self.results['failed'],
                'warnings': self.results['warnings'],
                'total': self.results['passed'] + self.results['failed'] + self.results['warnings']
            },
            'vulnerabilities': self.results['vulnerabilities']
        }
        
        # Calculate overall security score
        total = report['summary']['total']
        if total > 0:
            score = (report['summary']['passed'] / total) * 100
            report['summary']['score'] = round(score, 1)
        else:
            report['summary']['score'] = 0
        
        # Determine overall security rating
        if report['summary']['failed'] == 0:
            if report['summary']['warnings'] == 0:
                rating = 'A+'
            else:
                rating = 'A'
        elif report['summary']['failed'] <= 2:
            rating = 'B'
        elif report['summary']['failed'] <= 5:
            rating = 'C'
        else:
            rating = 'F'
        
        report['summary']['rating'] = rating
        
        # Output report
        report_file = 'security_test_report.json'
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        logger.info(f"Security test report saved to {report_file}")
        
        # Print summary
        print("\n" + "="*50)
        print("SECURITY TEST REPORT SUMMARY")
        print("="*50)
        print(f"Tests passed:  {report['summary']['passed']}")
        print(f"Tests failed:  {report['summary']['failed']}")
        print(f"Warnings:      {report['summary']['warnings']}")
        print(f"Total tests:   {report['summary']['total']}")
        print(f"Security score: {report['summary']['score']}% (Rating: {rating})")
        print("="*50)
        
        if report['vulnerabilities']:
            print("\nVULNERABILITIES FOUND:")
            for vuln in report['vulnerabilities']:
                print(f"- {vuln['severity'].upper()}: {vuln['title']}")
                print(f"  {vuln['description']}")
                print(f"  Recommendation: {vuln['recommendation']}")
                print()
        
        return report


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='HIPAA Security Penetration Testing Script')
    parser.add_argument('--all', action='store_true', help='Run all tests')
    parser.add_argument('--encryption', action='store_true', help='Test encryption only')
    parser.add_argument('--access-control', action='store_true', help='Test access controls only')
    parser.add_argument('--audit', action='store_true', help='Test audit logging only')
    parser.add_argument('--authentication', action='store_true', help='Test authentication only')
    parser.add_argument('--session', action='store_true', help='Test session security only')
    parser.add_argument('--api', action='store_true', help='Test API security only')
    parser.add_argument('--report', action='store_true', help='Generate report only')
    
    args = parser.parse_args()
    
    # If no arguments, run all tests
    if not any(vars(args).values()):
        args.all = True
    
    # Initialize test framework
    test = SecurityPenetrationTest()
    
    # Run tests based on arguments
    if args.all:
        test.run_all_tests()
    else:
        if args.encryption:
            test.test_encryption()
        if args.access_control:
            test.test_access_controls()
        if args.audit:
            test.test_audit_logging()
        if args.authentication:
            test.test_authentication()
        if args.session:
            test.test_session_security()
        if args.api:
            test.test_api_security()
        if args.report or not any([args.encryption, args.access_control, args.audit, 
                                 args.authentication, args.session, args.api]):
            test.generate_report()